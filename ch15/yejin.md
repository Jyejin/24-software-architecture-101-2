# ch 15. 공간 기반 아키텍처 스타일

-----

## 15.1 토폴로지
- 중앙 데이터베이스를 없애는 대신, 복제된 인메모리 데이터 그리드를 활용.
- 데이터를 업데이트할 때, persistent queue에 메시지를 보내는 식으로 데이터 비동기 전송
- 구성
  - 처리 장치
  - 가상 미들웨어
  - 데이터 펌프
  - 데이터 라이터
  - 데이터 리더

### 15.1.1 처리 장치
- 애플리케이션 코드가 구현된 장치

### 15.1.2 가상 미들웨어
- 데이터 동기화 및 요청 처리의 다양한 부분을 제어하는 인프라
- 구성
  - 메시징 그리드 : 미들웨어로 요청 유입 시, 어느 활성 처리 장치가 처리할지 결정 및 요청 전달.
  - 데이터 그리드 : 처리 장치 간의 데이터 동기화
  - 처리 그리드 : 요청 처리를 오케스트레이트하는 역할.
  - 배포 관리자 : 처리 장치를 동적으로 시작/종료하는 역할.

### 15.1.3 데이터 펌프
- 데이터를 다른 프로세서에 보내 데이터베이스를 업데이트하는 장치
- 대개 메시징 기법으로 구현.
- 도메인이나 서브도메인 별로 여러개 사용

### 15.1.4 데이터 라이터
- 데이터 펌프에서 메시지를 받아 데이터베이스에 업데이트하는 역할.

### 15.1.5 데이터 리더
- 데이터베이스에서 데이터를 읽어오는 역할.
- 다음의 경우에만 작동
    - 동일한 이름의 캐시를 가진 모든 처리 장치 인스턴스가 실패하는 경우.
    - 동일한 이름의 캐시 안에서 모든 처리 장치를 재배포하는 경우.
    - 복제 캐시에 들어있지 않은 아카이브 데이터를 조회하는 경우.

## 15.2 데이터 충돌
- 복제 레이턴시로 인해 데이터 충돌이 발생할 수 있다.
- 데이터 충돌률을 계산해 복제 캐시가 쓸만한지 미리 파악할 수 있다.

## 15.4 복제 캐시 대 분산 캐시
- 복제 캐시
  - 처리 장치 별로 동일한 캐시를 자체 인메모리 데이터 그리드로 갖고 있으며, 한 처리 장치에서 캐시가 업데이트 되면 다른 처리 장치도 새로운 데이터로 자동 업데이트
  - 속도가 매우빠르며 높은 수준의 내고장성을 지원.
  - 단일 장애점이 없음
  - 그러나 데이터량이 엄청 많거나, 데이터가 빈번하게 업데이트 되는 경우 사용에 어려움이 발생할 수 있음.
  - 데이터 크기만큼 모든 처리 장치에 복제되므로, 데이터 크기가 크면 메모리 사용량이 매우 커짐.
  - 데이터 업데이트율이 높으면 데이터 그리드가 동기화 속도를 따라잡지 못할수도 있음.
- 분산 캐시
  - 중앙 캐시를 갖고 있는 전용 외부 서비스 필요.
  - 전용 프로토콜을 통해 중앙 캐시 서버에 액세스.
  - 높은 수준의 데이터 일관성을 보장.
  - 원격에서 가져오므로 복제 캐시보다 느리며 전체 레이턴시가 증가함.

## 15.5 니어캐시
- 분산 캐시와 인메모리 데이터 그리드를 접합한 일종의 하이브리드 캐시 모델.
- 분산 캐시를 풀 백킹 캐시, 인메모리 데이터 그리드는 프런트 캐시로 지칭.
- 프런트 캐시에 MRU, MFU 등 정책을 설정하여 새 항목을 추가할 공간이 필요할 때마다 옛 항목 삭제
- 프런트 캐시는 항상 풀 백킹 캐시와 동기화 되지만 각 처리 장치에 포함된 프런트 캐시와는 동기화하지 않음.
- 장치마다 상이한 데이터를 갖게 됨. -> 일관성의 결여

## 15.6 구현 예시
### 콘서트 티켓 판매 시스템
- 특정 콘서트에 따라 티켓 판매 수 급증 
- 좌석 선택 가능 여부
- 유저 및 요청 부하가 예기치 않게 폭증하는 특징
- 신속하게, 지속적으로 업데이트 되어야 함. -> 공간 기반 아키텍처가 딱!
- 온라인 경매 시스템도 마찬가지..